from __future__ import annotations
from collections import deque
import pygame
import typing

ColorValue: typing.TypeAlias = typing.Union[typing.Tuple[int, int, int], typing.Sequence, pygame.Color]

_ExitCode: typing.TypeAlias = typing.Union[str, int, None]

P = typing.ParamSpec("P")

T = typing.TypeVar("T", bound=typing.Callable)
T2 = typing.TypeVar("T2")

def standardize_color(color: ColorValue) -> pygame.Color: ...

class Vec2D(typing.Tuple[int, int]):
    def __new__(cls, x: float, y: float) -> Vec2D: ...
    def __add__(self, other: typing.Tuple[float, float]) -> Vec2D: ...
    def __mul__(self, other: typing.Tuple[float, float])-> typing.Union[Vec2D, float]: ...
    def __rmul__(self, other: typing.Tuple[float, float]) -> Vec2D: ...
    def __sub__(self, other: typing.Tuple[float, float]) -> Vec2D: ...
    def __neg__(self) -> Vec2D: ...
    def __abs__(self) -> float: ...
    def rotate(self, angle: int) -> Vec2D: ...
    def __getnewargs__(self) -> typing.Tuple[float, float]: ...
    def __repr__(self) -> str: ...

class Pen:
    position: Vec2D
    heading: float
    color: pygame.Color
    size: int
    figure: typing.Optional[pygame.Surface]
    path: typing.List[typing.List[Vec2D]]

    def __init__(
        self, 
        position: Vec2D, 
        heading: float, 
        color: ColorValue, 
        size: int, 
        figure: typing.Optional[pygame.Surface] = None
    ) -> None: ...

    def set_size(self, size: int = 2) -> None: ...
    def set_speed(self, speed: float = 50) -> None: ...
    @typing.overload
    def set_color(self, r: int, g: int, b: int) -> None: ...
    @typing.overload
    def set_color(self, color: ColorValue) -> None: ...
    def set_color(self, *args: typing.Any) -> None: ...
    def hide(self) -> None: ...
    def show(self) -> None: ...
    def penup(self) -> None: ...
    def pendown(self) -> None: ...

class Navigator:
    heading: float
    speed: float

    def __init__(
        self, 
        position: Vec2D, 
        heading: float = 0.0, 
        speed: float = 0.0
    ) -> None: ...
    @property
    def position(self) -> Vec2D: ...
    def forward(self, distance: float) -> None: ...
    @typing.overload
    def goto(self, x: int, y: int) -> None: ...
    @typing.overload
    def goto(self, pos: Vec2D) -> None: ...
    def goto(self, x: typing.Union[Vec2D, int], y: typing.Optional[int] = None) -> None: ...
    @typing.overload
    def teleport(self, x: int, y: int) -> None: ...
    @typing.overload
    def teleport(self, pos: Vec2D) -> None: ...
    def teleport(self, x: typing.Union[Vec2D, int], y: typing.Optional[int] = None) -> None: ...
    def left(self, angle: float) -> None: ...
    def right(self, angle: float) -> None: ...
    def home(self) -> None: ...
    def setx(self, x: float) -> None: ...
    def sety(self, y: float) -> None: ...
    def set_heading(self, angle: float) -> None: ...
    @typing.overload
    def head_towards(self, x: float, y: float) -> None: ...
    @typing.overload
    def head_towards(self, pos: typing.Union[Vec2D, Navigator]) -> None: ...
    def head_towards(self, *args: typing.Any) -> None: ...
    @typing.overload
    def distance(self, x: float, y: float) -> Vec2D: ...
    @typing.overload
    def distance(self, pos: typing.Union[Vec2D, Navigator]) -> Vec2D: ...
    def distance(self, x: typing.Union[Vec2D, Navigator, float], y: typing.Optional[float] = None) -> Vec2D: ...
    @typing.overload
    def towards(self, x: float, y: float) -> float: ...
    @typing.overload
    def towards(self, pos: typing.Union[Vec2D, Navigator]) -> float: ...
    def towards(self, x: typing.Union[Vec2D, Navigator, float], y: typing.Optional[float] = None) -> float: ...
    def circle(
        self, 
        queue: deque, 
        radius: int, 
        steps: typing.Optional[int] = None, 
        direction: typing.Literal["left", "right"] = "left"
    ) -> None: ...

class Screen:
    surface: pygame.Surface
    clock: pygame.time.Clock
    dt: float
    target_fps: float

    def __init__(
        self, 
        width: int, 
        height: int, 
        *, 
        target_fps: float = 60.0
    ) -> None: ...
    @staticmethod
    def set_caption(title: str) -> None: ...
    @staticmethod
    def set_icon(surface: pygame.Surface) -> None: ...
    @staticmethod
    def flip() -> None: ...
    @typing.overload
    def set_background(self, r: int, g: int, b: int) -> None: ...
    @typing.overload
    def set_background(self, color: ColorValue) -> None: ...
    @typing.overload
    def set_background(self, image: pygame.Surface) -> None: ...
    def set_background(self, *args: typing.Any) -> None: ...
    def tick(self) -> None: ...
    def clear(self) -> None: ...
    def update(self) -> None: ...
    def mainloop(self) -> None: ...

class _QueuedArgument(typing.Generic[P, T2]):
    func: typing.Callable[P, T2]
    args: typing.Sequence[typing.Any]
    kwargs: typing.Dict[str, typing.Any]

    def __new__(self, func: typing.Callable[P, T2], *args: P.args, **kwargs: P.kwargs) -> _QueuedArgument[P, T2]: ...
    def __call__(self) -> T2: ...

class Turtle(Pen, Navigator):
    screen: typing.ClassVar[Screen] = None

    heading: float
    speed: float
    color: pygame.Color
    size: int
    figure: typing.Optional[pygame.Surface]
    path: typing.List[typing.List[Vec2D]]
    undo_stack: int
    redo_path: typing.List[Vec2D]
    redo_command: typing.List[typing.Tuple[typing.Callable, ...]]

    def __init__(
        self, 
        figure: typing.Optional[pygame.Surface] = None, 
        undo_stack: int = 1000, 
        visible: bool = True
    ) -> None: ...
    @property
    def position(self) -> Vec2D: ...
    def reset(self) -> None: ...
    def set_figure(self, surface: pygame.Surface) -> None: ...
    def clear(self) -> None: ...
    def undo(self) -> None: ...
    def redo(self) -> None: ...
    def dot(self) -> None: ...
    def circle(
        self, 
        radius: int, 
        steps: typing.Optional[int] = None, 
        direction: typing.Literal["left", "right"] = "left"
    ) -> None: ...
    def custom_command(
        self, 
        id_or_func: typing.Union[typing.Callable, int], 
        *args: typing.Any
    ) -> None: ...
    def commit(self) -> None: ...

def queue(func: typing.Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> _QueuedArgument[P, T]: ...
def init() -> None: ...
def exit(status: _ExitCode = None) -> typing.NoReturn: ...